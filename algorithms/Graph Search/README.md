# 그래프 탐색 알고리즘(Graph Search Algorithm)

## 1. 개요

![image](https://github.com/nicehcy2/baekjoon/assets/105339362/19903fae-3361-42bc-a545-ff3f9e2e1cf4)

그래프 탐색 문제란 여러 개체들이 연결되어 있는 자료구조인 그래프에서 특정 개체를 찾기 위한 알고리즘이다.

그래프 탐색 알고리즘에는 흔히 **너비 우선 탐색(BFS)** 과 **깊이 우선 탐색(DFS)** 이 있다. <br/><br/>

## 2. 대표적 문제 유형
1. 경로탐색 유형 (최단 거리, 시간)
2. 네트워크 유형 (연결)
3. 조합 유형 (모든 조합 만들기) <br/><br/>

## 3. 구현 방법

### 깊이 우선 탐색(Depth-First Search, DFS)

<br/>

DFS는 **깊이 우선 탐색**이라고 불리며 그래프의 시작점에서 다음 브랜치로 넘어가기 전에, 해당 브랜치를 모두 탐색한다.

알고리즘의 개요는 시작점 -> 시작점에 연결된 정점 -> 시작점에 연결된 정점에 연결된 정점 ~~ 식으로 **재귀** 혹은 **스택**을 통해 탐색을 수행하고 더 이상 연결된 간선이 없을 때까지 탐색하면 다시 되돌아가 연결된 정점을 탐색한다.

시간 복잡도는 아래와 같다.

- 인접 행렬: O(V^2)
- 인접 리스트: O(V+E)

메모리 측면에서 보면, 인접 행렬 방식은 모든 관계를 저장하므로 정점 개수가 많을 수록 메모리가 낭비된다. 반면, 리스트 방식은 연결된 정보만을 저장하기 때문에 메모리를 효율적으로 사용한다. 

**메모리 효율: 인접 리스트 > 인접 행렬**

속도 측면에서 보면, 인접 행렬 방식은 바로 확인이 가능하지만, 인접 리스트는 노드에 대한 인접 리스트를 차례로 수행하여야므로 정보를 얻는 속도가 는리다.

**조회 속도: 인접 리스트 < 인접 행렬**

코딩 테스트에서는 주로 **인접 행렬**의 데이터를 **재귀 함수**를 통해 탐색한다. <br/><br/>

```c++
  void dfs(int x)
  {
  	visited[x] = true;
  	cout << x << " ";

  	for (int i = 0; i < graph[x].size(); i++) // 인접한 노드 사이즈만큼 탐색
  	{
  		int y = graph[x][i];
  		if (!visited[y]) // visited가 False일 때 not을 해주면 True가 되므로 아래 dfs 실행
              dfs(y); // 재귀적으로 방문
  	}
  }
``` 

|장점| - 단지 현 경로 상의 노드 만을 기억하면 되므로 저장공간의 수요가 비교적 적음 <br/> - 목표 노드가 깊은 단계에 있을 경우 해를 빠르게 구할 수 있음 <br/> - 구현이 비교적 간단|
|---|:---|
|단점| - 무한 루프 가능성(재방문 여부를 반드시 검사하고 해가 없는 경우를 조심) <br/> - 얻어진 해가 최단 경로가 된다는 보장이 없음 |

<br/><br/>

### 2. 너비 우선 탐색(Breadth-First Search, BFS)

<br/>

BFS는 **너비 우선 탐색**이라고 불리며 그래프의 시작점에서 가까운 점들부터 우선적으로 탐색한다.

시작점을 **queue**에 넣은 뒤에, 큐에 아무런 요소가 없을 때까지 **인접한 정점**들을 탐색해 나아가며 진행된다.

시간 복잡도

- 인접 행렬: O(V^2)
- 인접 리스트: O(V + E)

![image](https://github.com/nicehcy2/baekjoon/assets/105339362/682885de-dd3b-4ad5-b876-904b49cce3a1)

1. 시작점인 1을 큐에 넣고 방문처리를 한다.
2. 1을 꺼내고 인접한 정점인 2,3,8을 큐에 넣고 방문처리를 한다.
3. 큐에서 2를 꺼내고 방문하지 않은 7을 꺼내서 방문처리
4. 큐에서 3을 꺼내고 방문하지 않은 4,5를 꺼내서 방문처리
5. 위와 같이 큐에서 더이상 꺼낼것이 없을때까지 반복

<br/>

```c++
  // BFS 함수 정의
  void bfs(int start) {
      queue<int> q;
      q.push(start); // 첫 노드를 queue에 삽입
      visited[start] = true; // 첫 노드를 방문 처리
  
      // 큐가 빌 때까지 반복
      while (!q.empty()) {
          // 큐에서 하나의 원소를 뽑아 출력
          int x = q.front();
          q.pop();
          cout << x << ' ';
          // 해당 원소와 연결된, 아직 방문하지 않은 원소들을 큐에 삽입
          for (int i = 0; i < graph[x].size(); i++) {
              int y = graph[x][i];
              if (!visited[y]) {
                  q.push(y);
                  visited[y] = true;
              }
          }
      }
  }
```

|장점| - 출발 노드에서 목표 노드까지의 최단 길이 경로를 보장 |
|---|:---|
|단점| - 많은 기억 공간을 필요 <br/> - 무한 그래프의 경우에는 해를 찾지도 못하고, 끝내지도 못함 <br/> - 해가 존재하지 않는 유한 그래프의 경우, 모든 그래프를 탐색한 후에 실패로 끝남 |

<br/><br/>

## 4. DFS/BFS 중 어떤 것을 사용해야할까?

둘 다 탐색을 하는 알고리즘이기 때문에 최단 거리 문제가 아닌 이상 어떤 것을 사용해도 정답이 나온다.

DFS가 구현이 쉽고 동작 검증이 쉬워 주로 사용된다. DFS는 하나의 조합을 완성해서 정답과 비교하기 때문에 동작 검증이 쉽다. 

그러나 BFS가 시간복잡도가 더 낮기 떄문에 시간 제한이 적은 문제를 풀 때 유리하다. 또한 **최단 거리**문제를 쉽게 풀 수 있다. <br/><br/>

[메인으로 돌아가기](https://github.com/nicehcy2/baekjoon/tree/main)
