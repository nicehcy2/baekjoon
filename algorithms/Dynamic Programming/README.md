# Dynamic Programming(동적 계획법)

## 1. 개요

<br/>

**DP, 즉 다이나믹 프로그래밍(또는 동적 계획법)** 은 **하나의 큰 문제를 여러 개의 작은 문제로 나누어서 그 결과를 저장하여 다시 큰 문제를 해결할 때 사용**하는 것으로 
특정한 알고리즘이 아닌 하나의 문제해결 패러다임으로 볼 수 있다. <br/><br/>
요약하면 동적 계획법은 **큰 문제를 작은 문제로 쪼개서 그 답을 저장해두고 재활용**한다. <br/><br/>

## 2. DP를 쓰는 이유

<br/>

DP를 사용하는 이유는 연산이 빨라 시간복잡도를 개선할 수 있기 때문이다. 사실 일반적인 재귀(Recursion) 방식 또한 DP와 매우 유사하다. 재귀 방식도 큰 문제를 작은 문제로 쪼개서, 가장 작은 단위로 분할하여 문제를 해결한다. 그러나 일반적인 재귀를 단순히 사용 시 동일한 작은 문제들이 여러 번 반복되어 비효율적인 계산이 될 수 있다.<br/><br/>

피보나치 문제를 재귀를 사용하여 풀 경우, 반복되는 계산을 하게 된다. 그러나 한 번 구한 작은 문제의 결과 값을 저장해두고 재사용 한다면 계산된 값을 다시 반복할 필요가 없다. <br/><br/>

즉, 매우 효율적으로 문제를 해결할 수 있게 된다. <br/><br/>

## 3. DP의 사용조건

<br/>

DP가 적용되기 위해서는 2가지 조건을 만족해야 한다.
- Overlapping Subproblems(겹치는 부분 문제)
- Optimal Substructure(최적 부분 구조)

<br/>

#### ① Overlapping Subproblems
DP는 기본적으로 문제를 나누고 그 문제의 결과 값을 재활용하여 전체 답을 구한다. 그래서 **동일한 작은 문제들이 반복하여 나타나는 경우**에 사용이 가능하다. <br/><br/>
즉, DP는 부분 문제의 결과를 저장하여 재 계산하지 않을 수 있어야하는데, 해당 부분 문제가 반복적으로 나타나지 않는담녀 재사용이 불가능하니 부분문제가 중복되지 않는 경우에는
사용될 수 없다.

#### ② Optimal Substructure
**부분 문제의 최적 결과 값을 사용해 전체 문제의 최적 결과를 낼 수 있는 경우**를 의미한다. 그래서 특정 문제의 정답은 문제의 크기에 상관없이 항상 동일하다. 

![image](https://github.com/nicehcy2/baekjoon/assets/105339362/5714d137-bbdb-437a-a324-76a0fd9e5621)

최단 경로 찾기와 같이, 부분 문제에서 구한 최적 결과가 전체 문제에서도 동일하게 적용되어 결과가 변하지 않을 때 DP를 사용할 수 있게 된다. <br/>
피보나치 수열도 동일하게 이전의 계산 값을 그대로 사용하여 전체 답을 구할 수 있어 최적 부분 구조를 갖고 있다. <br/><br/>

## 4. DP 사용하기

<br/>

일반적으로 DP를 사용하기 전에는 아래의 과정을 거쳐 진행할 수 있다.
1. DP로 풀 수 있는 문제인지 확인한다. (사용조건 확인)
2. 문제의 변수 파악
3. 변수 간 관계식 만들기(점화식)
4. 메모하기(memoization or tabulation)
5. 기저 상태 파악하기
6. 구현

#### ① DP로 풀 수 있는 문제인지 확인
이 부분부터 해결이 매우 어렵다. 앞에서 언급한 조건들이 충족되는 문제인지를 체크해야 한다. 

보통 특정 데이터 내 최대화 / 최소화 계산을 하거나 특정 조건 내 데이터를 세야 한다거나 확률 등의 계산의 경우 DP로 풀 수 있는 경우가 많다. 

분할 정복, 그리디, (가끔식 그래프 이론)과 헷갈리는 경우가 많다. 보통 코딩테스트에선 DP로 풀어야 하는 문제를 다른 알고리즘으로 풀었을 경우 시간 초과 혹은 메모리 초과 문제가 발생하므로 계산할 연산이 많으면 DP를 푸는 방식으로 생각해보자. <br/><br/>

#### ② 문제의 변수 파악
DP는 현재 변수에 따라 그 결과 값을 찾고 그것을 전달하여 재사용하는 것을 거친다. 즉, 문제 내 변수의 개수를 알아내야 한다는 것. 이것을 **state**를 결정한다고 한다.

예를 들어, 피보나치 수열에서는 n번째 숫자를 구하는 것이므로 n이 변수가 된다. 그 변수가 얼마이냐에 따라 결과값이 다르지만 그 결과를 재사용하고 있다. 

또한, 문자열 간의 차이를 구할 때는 문자열의 길이, Edit 거리 등 2 가지 변수를 사용하고 Knapsack 문제에서는 index, 무게로 2가지의 변수를 사용한다. 

이와 같이 해당 문제에서 어떤 변수가 있는지를 파악해야 그에 따른 답을 구할 수 있다. (동시에 값의 종류를 생각하는 것도 좋다) <br/><br/>

#### ③ 변수 간 관계식 만들기
가장 어려운 부분이다. 변수들에 의해 결과값이 달라지지만 동일한 변수값인 경우 결과는 동일하다. 또한 우리는 그 결과값을 그대로 이용할 것이므로 그 관계식을 만들어 낼 수 있어야 한다.

그러한 식을 점화식이라고 부르며 이를 사용하면 짧은 코드에서 반복(Bottom-Up)/재귀(Top-Down)를 통해 문제가 자동으로 해결되도록 구현할 수 있다.

_ex) f(n) = f(n-1) + f(n-2)_ <br/><br/>

#### ④ 메모하기
변수 간 관계식을 정상적으로 생성했다면 변수의 값에 따른 결과를 저장해야 한다. 이것을 메모한다고 하여 **Memoization**이라고 부른다.

변수 값에 따른 결과를 저장할 배열 등을 만들고 그 결과를 나올 때마다 배열 내에 저장하고 그 저장된 값을 재사용하는 방식으로 문제를 해결해 나간다.

이 결과 값을 저장할 때는 보통 배열을 쓰며 변수의 개수에 따라 배열의 차원이 다양할 수 있다. <br/><br/>

#### ⑤ 기저 상태 파악하기
가장 작은 문제의 상태를 알아야 한다.

해당 기저 문제에 대해 파악 후 미리 배열 등에 저장해두면 된다.(초기값) <br/><br/>

#### ⑥ 구현하기
1. Bottom-Up (Tabulation 방식) - 반복문 사용
2. Top-Down (Memoization 방식) - 재귀 사용

##### ① Bottom-Up 방식
**아래에서 부터 계산을 수행 하고 누적시켜서 전체 큰 문제를 해결하는 방식이다.**

메모를 위해서 dp라는 배열을 만들었고 이것이 1차원이라 가정했을 때, dp[0]가 기저 상태이고 dp[n]을 목표 상태라고 하자. Bottom-up은 dp[0]부터 시작하여 반복문을 통해 점화식으로 결과를 내서 dp[n]까지 그 값을 전이시켜 재활용하는 방식이다.

사실 위에서 메모하기 부분에서 Memoization이라고 했는데 Bottom-up일 때는 Tabulation이라고 부른다.

왜냐면 반복을 통해 dp[0]부터 하나 하나씩 채우는 과정을 "table-filling" 하며, 이 Table에 저장된 값에 직접 접근하여 재활용하므로 Tabulation이라는 명칭이 붙었다고 한다.

사실상 근본적인 개념은 결과값을 기억하고 재활용한다는 측면에서 메모하기(Memoization)와 크게 다르지 않다.

##### ② Top-Down 방식
이는 dp[0]의 기저 상태에서 출발하는 대신 dp[n]의 값을 찾기 위해 위에서 부터 바로 호출을 시작하여 dp[0]의 상태까지 내려간 다음 해당 결과 값을 재귀를 통해 전이시켜 재활용하는 방식이다.

피보나치의 예시처럼, f(n) = f(n-2) + f(n-1)의 과정에서 함수 호출 트리의 과정에서 보이듯, n=5일 때, f(3), f(2)의 동일한 계산이 반복적으로 나오게 된다.

이 때, 이미 이전에 계산을 완료한 경우에는 단순히 메모리에 저장되어 있던 내역을 꺼내서 활용하면 된다. 그래서 가장 최근의 상태 값을 메모해 두었다고 하여 Memoization 이라고 부른다.

## 5. 기타내용

## 6. 다시 풀만한 문제
[메인으로 돌아가기](https://github.com/nicehcy2/baekjoon)
